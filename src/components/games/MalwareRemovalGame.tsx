import React, { useEffect, useRef, useState } from 'react';
import {IGamePropsBase} from "./interfaces/gameprops.interface.ts";

interface Block {
    text: string;
    x: number;
    y: number;
    speed: number;
    isProtected: boolean;
}

const wordList = ["apple", "banana", "cat", "dog", "house", "keyboard", "mouse", "water", "earth", "space"];
interface MalwareRemovalGameProps extends IGamePropsBase {
    onWin: () => void;
}
const MalwareRemovalGame: React.FC<MalwareRemovalGameProps> = ({onWin}) => {
    const canvasRef = useRef<HTMLCanvasElement | null>(null);
    const [blocks, setBlocks] = useState<Block[]>([]);
    const [health, setHealth] = useState<number>(8);
    const [score, setScore] = useState<number>(0);
    const [gameOver, setGameOver] = useState<boolean>(false);
    const [regexInput, setRegexInput] = useState<string>('');
    const [errorMessage, setErrorMessage] = useState<string | null>(null);
    const winCondition = 5;

    // Function to update and render the game canvas
    useEffect(() => {
        const canvas = canvasRef.current;
        const ctx = canvas?.getContext('2d');

        const updateGame = () => {
            if (!ctx || gameOver) return;

            // @ts-ignore
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            blocks.forEach((block) => {
                block.y += block.speed;
                ctx.fillStyle = block.isProtected ? '#ff4141' : '#00ff00';  // Red for protected words
                ctx.font = '20px Arial';
                ctx.fillText(block.text, block.x, block.y);
            });

            if (health <= 0) {
                endGame(ctx);
            }

            requestAnimationFrame(updateGame);
        };

        updateGame();
    }, [blocks, gameOver, health]);

    // Spawn a new block with random text
    const spawnBlock = () => {
        const isProtected = Math.random() < 0.3; // 30% chance to spawn a protected word
        const text = generateRandomText(isProtected);
        const newBlock: Block = {
            text: text,
            x: Math.random() * 700, // Adjust X positioning
            y: 0, // Start at the top of the canvas
            speed: Math.random() * 1.5 + 0.5, // Random speed for falling blocks
            isProtected,
        };
        setBlocks((prevBlocks) => [...prevBlocks, newBlock]);
    };

    // Helper function to generate random text
    const generateRandomText = (isProtected = false): string => {
        const word = wordList[Math.floor(Math.random() * wordList.length)];
        const extraChars = ['@', '#', '!', '$', '%', '^', '&', '*'];
        let result = word;
        const randomExtras = Math.floor(Math.random() * 3) + 1;
        for (let i = 0; i < randomExtras; i++) {
            result += extraChars[Math.floor(Math.random() * extraChars.length)];
        }
        return result;
    };

    // Apply the regular expression to eliminate blocks
    const applyRegex = () => {
        try {
            const regex = new RegExp(regexInput);
            let blocksCleared = 0;

            setBlocks((prevBlocks) =>
                prevBlocks.filter((block) => {
                    if (regex.test(block.text)) {
                        if (block.isProtected) {
                            setHealth((prevHealth) => prevHealth - 1); // Decrease health if protected block is eliminated
                        } else {
                            setScore((prevScore) => prevScore + 1); // Increase score for valid block removal
                            blocksCleared++;
                        }
                        return false;
                    }
                    return true;
                })
            );

            setErrorMessage(null); // Clear any previous error message

            if (score + blocksCleared >= winCondition) {
                winGame();
            }
        } catch (e) {
            setErrorMessage(`Error: Invalid regex pattern "${regexInput}". Please try again.`);
        }

        setRegexInput(''); // Clear input after applying regex
    };

    // Game win and lose conditions
    const endGame = (ctx: CanvasRenderingContext2D) => {
        setGameOver(true);
        ctx.fillStyle = '#ff4141';
        ctx.font = '30px Arial';
        ctx.fillText('Game Over!', 300, 200);
    };

    const winGame = () => {
        setGameOver(true);
        const ctx = canvasRef.current?.getContext('2d');
        if (ctx) {
            ctx.fillStyle = '#00ff00';
            ctx.font = '30px Arial';
            ctx.fillText('You Win!', 300, 200);
        }
        setTimeout(()=>{
            onWin()
        }, 1000)
    };

    // Replay game
    const replayGame = () => {
        setGameOver(false);
        setHealth(8);
        setScore(0);
        setBlocks([]);
    };

    useEffect(() => {
        if (!gameOver) {
            const interval = setInterval(() => {
                spawnBlock();
            }, Math.random() * 2000 + 1000);

            return () => clearInterval(interval);
        }
    }, [gameOver]);

    return (
        <div>
            <h1>Regex Block Eliminator</h1>
            <p>
                Type a regex pattern to eliminate falling blocks. Be careful! Blocks in red are protectedâ€”
                if you eliminate them, you lose 1 health point.
            </p>
            <canvas ref={canvasRef} width={800} height={400} style={canvasStyle}></canvas>
            <div>
                <input
                    type="text"
                    value={regexInput}
                    placeholder="Enter regex..."
                    onChange={(e) => setRegexInput(e.target.value)}
                    onKeyPress={(e) => e.key === 'Enter' && applyRegex()}
                    style={inputStyle}
                />
                <button onClick={applyRegex} style={buttonStyle}>
                    Apply Regex
                </button>
            </div>
            {errorMessage && <p style={errorStyle}>{errorMessage}</p>}
            <p>Health: {health}</p>
            <p>Score: {score}</p>
            {gameOver && <button onClick={replayGame} style={buttonStyle}>Replay</button>}
        </div>
    );
};

// Styling
const canvasStyle = {
    border: '2px solid #00ff00',
    backgroundColor: '#141414',
    display: 'block',
    margin: '20px auto',
};

const inputStyle = {
    padding: '10px',
    fontSize: '16px',
    width: '300px',
    marginRight: '10px',
};

const buttonStyle = {
    padding: '10px 20px',
    fontSize: '16px',
    backgroundColor: '#00ff00',
    color: '#0e0e0e',
    border: 'none',
    cursor: 'pointer',
};

const errorStyle = {
    color: '#ff4141',
};

export default MalwareRemovalGame;
