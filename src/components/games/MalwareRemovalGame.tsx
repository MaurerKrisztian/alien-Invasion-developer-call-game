import React, { useEffect, useRef, useState } from 'react';
import { IGamePropsBase } from './interfaces/gameprops.interface.ts';

interface Block {
    text: string;
    x: number;
    y: number;
    speed: number;
    isProtected: boolean;
}

const wordList = ['apple', 'banana', 'cat', 'dog', 'house', 'keyboard', 'mouse', 'water', 'earth', 'space'];

interface MalwareRemovalGameProps extends IGamePropsBase {
    onWin: () => void;
    winCondition: number;
    healthNr: number;
}

const MalwareRemovalGame: React.FC<MalwareRemovalGameProps> = ({ winCondition = 5, healthNr = 8, onWin }) => {
    const canvasRef = useRef<HTMLCanvasElement | null>(null);
    const [blocks, setBlocks] = useState<Block[]>([]);
    const [health, setHealth] = useState<number>(healthNr);
    const [score, setScore] = useState<number>(0);
    const [gameOver, setGameOver] = useState<boolean>(false);
    const [regexInput, setRegexInput] = useState<string>('');
    const [errorMessage, setErrorMessage] = useState<string | null>(null);

    // Refs to hold mutable values without causing re-renders
    const blocksRef = useRef<Block[]>(blocks);
    const healthRef = useRef<number>(health);

    // Update refs whenever state changes
    useEffect(() => {
        blocksRef.current = blocks;
    }, [blocks]);

    useEffect(() => {
        healthRef.current = health;
    }, [health]);

    useEffect(() => {
        const canvas = canvasRef.current;
        const ctx = canvas?.getContext('2d');

        if (!canvas || !ctx) return;

        let animationFrameId: number;

        const updateGame = () => {
            if (gameOver) return;

            // Clear the canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Update and draw blocks
            const newBlocks = [];
            for (let block of blocksRef.current) {
                block.y += block.speed;

                // Draw the block
                ctx.fillStyle = block.isProtected ? '#ff4141' : '#00ff00'; // Red for protected words
                ctx.font = '20px Arial';
                ctx.fillText(block.text, block.x, block.y);

                // Check if block reached the bottom of the canvas
                if (block.y > canvas.height) {
                    if (!block.isProtected) {
                        setHealth((prevHealth) => prevHealth - 1); // Decrease health if green block reaches bottom
                    }
                    // Do not add to newBlocks to remove it
                } else {
                    newBlocks.push(block);
                }
            }

            // Update blocksRef and state
            blocksRef.current = newBlocks;
            setBlocks(newBlocks);

            if (healthRef.current <= 0) {
                endGame(ctx);
                return;
            }

            animationFrameId = requestAnimationFrame(updateGame);
        };

        // Start the game loop
        animationFrameId = requestAnimationFrame(updateGame);

        // Cleanup on unmount
        return () => {
            cancelAnimationFrame(animationFrameId);
        };
    }, [gameOver]); // Only run when gameOver changes

    // Spawn a new block with random text
    const spawnBlock = () => {
        const isProtected = Math.random() < 0.5;
        const text = generateRandomText(isProtected);
        const newBlock: Block = {
            text: text,
            x: Math.random() * (800 - 100), // Adjust X positioning within canvas width
            y: 0, // Start at the top of the canvas
            speed: Math.random() * 1.5 + 0.5, // Random speed for falling blocks
            isProtected,
        };
        setBlocks((prevBlocks) => [...prevBlocks, newBlock]);
        blocksRef.current = [...blocksRef.current, newBlock]; // Update the ref
    };

    // Helper function to generate random text
    const generateRandomText = (isProtected = false): string => {
        const word = wordList[Math.floor(Math.random() * wordList.length)];
        const extraChars = ['@', '#', '!', '$', '%', '^', '&', '*'];
        let result = word;
        const randomExtras = Math.floor(Math.random() * 3) + 1;
        for (let i = 0; i < randomExtras; i++) {
            result += extraChars[Math.floor(Math.random() * extraChars.length)];
        }
        return result;
    };

    // Apply the regular expression to eliminate blocks
    const applyRegex = () => {
        try {
            const regex = new RegExp(regexInput);
            let blocksCleared = 0;

            const remainingBlocks = [];
            for (let block of blocksRef.current) {
                if (regex.test(block.text)) {
                    if (block.isProtected) {
                        setHealth((prevHealth) => prevHealth - 1); // Decrease health if protected block is eliminated
                    } else {
                        setScore((prevScore) => prevScore + 1); // Increase score for valid block removal
                        blocksCleared++;
                    }
                    // Do not add to remainingBlocks to remove it
                } else {
                    remainingBlocks.push(block);
                }
            }

            blocksRef.current = remainingBlocks;
            setBlocks(remainingBlocks);

            setErrorMessage(null); // Clear any previous error message

            if (score + blocksCleared >= winCondition) {
                winGame();
            } else {
                setScore((prevScore) => prevScore + blocksCleared);
            }
        } catch (e) {
            setErrorMessage(`Error: Invalid regex pattern "${regexInput}". Please try again.`);
        }

        setRegexInput(''); // Clear input after applying regex
    };

    // Game win and lose conditions
    const endGame = (ctx: CanvasRenderingContext2D) => {
        setGameOver(true);
        ctx.fillStyle = '#ff4141';
        ctx.font = '30px Arial';
        ctx.fillText('Game Over!', 300, 200);
    };

    const winGame = () => {
        setGameOver(true);
        const ctx = canvasRef.current?.getContext('2d');
        if (ctx) {
            ctx.fillStyle = '#00ff00';
            ctx.font = '30px Arial';
            ctx.fillText('You Win!', 300, 200);
        }
        setTimeout(() => {
            onWin();
        }, 2000);
    };

    // Replay game
    const replayGame = () => {
        setGameOver(false);
        setHealth(healthNr);
        healthRef.current = healthNr;
        setScore(0);
        setBlocks([]);
        blocksRef.current = [];
    };

    useEffect(() => {
        if (!gameOver) {
            const interval = setInterval(() => {
                spawnBlock();
            }, Math.random() * 2000 + 1000);

            return () => clearInterval(interval);
        }
    }, [gameOver]);

    return (
        <div>
            <h1>Regex Block Eliminator</h1>
            <p>
                Type a regex pattern to eliminate falling blocks. Be careful! Blocks in red are protectedâ€”
                if you eliminate them, you lose 1 health point.
            </p>
            <canvas ref={canvasRef} width={800} height={400} style={canvasStyle}></canvas>
            <div>
                <input
                    type="text"
                    value={regexInput}
                    placeholder="Enter regex..."
                    onChange={(e) => setRegexInput(e.target.value)}
                    onKeyPress={(e) => e.key === 'Enter' && applyRegex()}
                    style={inputStyle}
                />
                <button onClick={applyRegex} style={buttonStyle}>
                    Apply Regex
                </button>
            </div>
            {errorMessage && <p style={errorStyle}>{errorMessage}</p>}
            <p>Health: {health}</p>
            <p>Score: {score}</p>
            {gameOver && (
                <button onClick={replayGame} style={buttonStyle}>
                    Replay
                </button>
            )}
        </div>
    );
};

// Styling
const canvasStyle = {
    border: '2px solid #00ff00',
    backgroundColor: '#141414',
    display: 'block',
    margin: '20px auto',
};

const inputStyle = {
    padding: '10px',
    fontSize: '16px',
    width: '300px',
    marginRight: '10px',
};

const buttonStyle = {
    padding: '10px 20px',
    fontSize: '16px',
    backgroundColor: '#00ff00',
    color: '#0e0e0e',
    border: 'none',
    cursor: 'pointer',
};

const errorStyle = {
    color: '#ff4141',
};

export default MalwareRemovalGame;
